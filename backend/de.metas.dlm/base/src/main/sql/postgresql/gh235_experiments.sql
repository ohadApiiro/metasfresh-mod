---
-- this is the view we use as benchmark
-- it's generated by the metasfresh client if we open the invoice candidate withod and filter for Updated >= 2016-06.16 15:51
--
EXPLAIN (ANALYZE, BUFFERS)

SELECT HeaderAggregationKeyBuilder_ID,IsPackagingMaterial,QualityInvoiceLineGroupType,LineAggregationKeyBuilder_ID,AD_Org_ID,C_Invoice_Candidate_ID,C_Invoice_Candidate_HeaderAggregation_Effective_ID,IsSOTrx,IsManual,
(CASE WHEN C_Invoice_Candidate.M_Material_Tracking_ID IS NULL THEN 'N' ELSE 'Y' END) AS IsMaterialTracking,
M_Material_Tracking_ID,Line,C_DocTypeInvoice_ID,C_ILCandHandler_ID,AD_Table_ID,Record_ID,Description,IsToClear,C_Order_ID,DateOrdered,C_OrderLine_ID,M_InOut_ID,  
(SELECT o.DatePromised from C_Order o where o.C_Order_ID = C_Invoice_Candidate.C_Order_ID) AS DatePromised,
First_Ship_BPLocation_ID,POReference,DeliveryDate,
(SELECT C_BPartner_ID FROM C_Order where C_Order_ID = C_Invoice_Candidate.C_Order_ID) AS C_Order_BPartner,C_Activity_ID,C_Charge_ID,M_Product_ID,
( select p.M_Product_Category_ID from M_Product p where p.M_Product_ID = C_Invoice_Candidate.M_Product_ID ) AS M_Product_Category_ID,
( select p.ProductType from M_Product p where p.M_Product_ID = C_Invoice_Candidate.M_Product_ID ) AS ProductType,
M_PricingSystem_ID,M_PriceList_Version_ID,C_Currency_ID,C_ConversionType_ID,C_Tax_ID,C_Tax_Override_ID,
COALESCE(C_Invoice_Candidate.C_Tax_Override_ID, C_Invoice_Candidate.C_Tax_ID) AS C_Tax_Effective_ID,QtyOrdered,QtyDelivered,QtyOrderedOverUnder,InvoiceRule,InvoiceRule_Override,
COALESCE(InvoiceRule_Override, InvoiceRule) AS InvoiceRule_Effective,
(select bp.C_InvoiceSchedule_ID from C_Bpartner bp where bp.C_BPartner_ID=C_Invoice_Candidate.Bill_BPartner_ID) AS C_InvoiceSchedule_ID,InvoiceScheduleAmtStatus,DateToInvoice,DateToInvoice_Override,
COALESCE(DateToInvoice_Override, DateToInvoice) AS DateToInvoice_Effective,DateInvoiced,DateAcct,QualityDiscountPercent,QualityDiscountPercent_Override,
COALESCE(C_Invoice_Candidate.QualityDiscountPercent_Override, C_Invoice_Candidate.QualityDiscountPercent) AS QualityDiscountPercent_Effective,QtyWithIssues,IsInDispute,QtyWithIssues_Effective,
( select rs.QualityNote from M_ReceiptSchedule rs where exists (select 1 from M_ReceiptSchedule_Alloc rsa where rsa.m_receiptschedule_id=rs.m_receiptschedule_id and rs.C_OrderLine_ID = C_Invoice_Candidate.C_OrderLine_ID) ) AS QualityNote_ReceiptSchedule,
ReasonDiscount,PriceEntered,PriceEntered_Override,IsTaxIncluded_Override,Discount,Discount_Override,PriceActual,PriceActual_Override,PriceActual_Net_Effective,
( select bp.Name from C_BPartner bp where bp.C_BPartner_ID = C_Invoice_Candidate.Bill_BPartner_ID ) AS Bill_BPartner_Name,
IsEdiRecipient,IsEdiEnabled,Bill_BPartner_ID,Bill_Location_ID,Bill_User_ID,QtyInvoiced,C_UOM_ID,QtyToInvoiceBeforeDiscount,QtyToInvoice_Override,QtyToInvoice_OverrideFulfilled,QtyToInvoice,QtyToInvoiceInPriceUOM,Price_UOM_ID,QtyEnteredTU,
(SELECT COALESCE(SUM(ROUND((ic.qtyToInvoiceInPriceUOM * COALESCE(ic.PriceActual_Override, ic.PriceActual)), 2)), 0) FROM C_Invoice_Candidate ic WHERE ic.C_Order_ID=C_Invoice_Candidate.C_Order_ID) AS TotalOfOrder,
(SELECT COALESCE(SUM(ROUND((ic.qtyToInvoiceInPriceUOM * COALESCE(ic.PriceEntered_Override, ic.PriceEntered)), 2)), 0) 

FROM C_Invoice_Candidate ic WHERE ic.C_Order_ID=C_Invoice_Candidate.C_Order_ID) AS TotalOfOrderExcludingDiscount,(SELECT SUM(ol.LineNetAmt) FROM C_OrderLine ol WHERE ol.C_OrderLine_ID=C_Invoice_Candidate.C_OrderLine_ID) AS LineNetAmt,
ApprovalForInvoicing,IsInOutApprovedForInvoicing,NetAmtToInvoice,NetAmtInvoiced,SplitAmt,C_Invoice_Candidate_Agg_ID,HeaderAggregationKey,LineAggregationKey,LineAggregationKey_Suffix,AD_User_InCharge_ID,
( case when exists (select 1 from C_Invoice_Candidate_Recompute icr where icr.C_Invoice_Candidate_ID=C_Invoice_Candidate.C_Invoice_Candidate_ID) then 'Y' else 'N' end ) AS IsToRecompute,IsError,
(CASE WHEN EXISTS (select 1 from T_Lock where T_Lock.Record_ID=C_Invoice_Candidate.C_Invoice_Candidate_ID and T_Lock.AD_Table_ID=(select AD_Table_ID from AD_Table where TableName='C_Invoice_Candidate')) THEN 'Y' ELSE 'N' END) AS Processing,
Processed_Calc,Processed_Override,Processed,SchedulerResult,ErrorMsg,DescriptionHeader,DescriptionBottom,IsPrinted,
(select rs.qualityDiscountPercent from M_ReceiptSchedule rs  where exists (select 1 from M_ReceiptSchedule_Alloc rsa where rsa.m_receiptschedule_id=rs.m_receiptschedule_id) and rs.C_OrderLine_ID = C_Invoice_Candidate.C_OrderLine_ID) AS QualityDiscountPercent_ReceiptSchedule,
Created,CreatedBy,IsActive,Updated,AD_Note_ID,AD_Client_ID,UpdatedBy,C_Invoice_Candidate_HeaderAggregation_Override_ID,IsTaxIncluded,HeaderAggregationKey_Calc,
C_Invoice_Candidate_HeaderAggregation_ID 

FROM C_Invoice_Candidate 

WHERE ( (Created>= TIMESTAMP '2016-06-16 15:51:00.0' )) 
	AND C_Invoice_Candidate.AD_Client_ID IN(0,1000000) 
	AND C_Invoice_Candidate.AD_Org_ID IN (0,1000004,1000001,1000000) 
	AND C_Invoice_Candidate.C_Invoice_Candidate_ID NOT IN ( SELECT Record_ID FROM AD_Private_Access WHERE AD_Table_ID = 540270 AND AD_User_ID <> 100 AND IsActive = 'Y' ) 

ORDER BY Created DESC
---

-- Results-Summary (TLDR)
-- on the DB, we have 1348927 ICs
-- on the DB-server, with only the DBMS running (no metasfres-server) and only one client connected, the query takes
-- more than *30 seconds* without "DLM"
-- ->aprox *15 seconds* if we set up DLM indices etc and move 1094035 IC to DLM_Level 1, together with those records that are referenced by those ICs via SQL-column. 
--   That leaves aprox 250'000 remaining in level 0. Note that on erpprod we calculate with aprox 60'000 ICs in dlm-level 0

-- The rest of this file contains notes about how I tested. I only used the client in the end, to verify that the chagnes are actually noticable.



--remove dlm stuff *including* the DLM_Level column, if it exists
SELECT dlm.remove_table_from_dlm('C_Invoice_Candidate', false);
SELECT dlm.remove_table_from_dlm('C_Order', false);
SELECT dlm.remove_table_from_dlm('C_OrderLine', false);
SELECT dlm.remove_table_from_dlm('M_ReceiptSchedule_Alloc', false);
SELECT dlm.remove_table_from_dlm('M_ReceiptSchedule', false);

-- make sure the planner knows what's up
ANALYZE VERBOSE C_Invoice_Candidate;
ANALYZE VERBOSE C_Order;
ANALYZE VERBOSE C_OrderLine;
ANALYZE VERBOSE M_ReceiptSchedule_Alloc;
ANALYZE VERBOSE M_ReceiptSchedule;


-- flush OS caches and restart postgres; see http://stackoverflow.com/a/1223421/1012103
-- root@DBMS:~# service postgresql stop && sync && echo 3 > /proc/sys/vm/drop_caches && service postgresql start

-- do explain analyze buffer etc..
-- "Sort  (cost=202367.29..202367.48 rows=79 width=2166) (actual time=207.712..208.143 rows=544 loops=1)"
-- Note that this wasn't reproducible on later runs. There we got 
-- pg-9.1: "Index Scan Backward using c_invoice_candidate_create on c_invoice_candidate  (cost=15.96..214555.65 rows=73  width=2106)  (actual time=116.984..1747.659 rows=544 loops=1)"
-- pg-9.5: "Index Scan Backward using c_invoice_candidate_create on c_invoice_candidate  (cost=16.28.. 41663.41 rows=106 width=2085)  (actual time=132.856..1535.716 rows=544 loops=1)"
--- instead.



-- now enable DLM
SELECT dlm.add_table_to_dlm('C_Invoice_Candidate');
SELECT dlm.add_table_to_dlm('C_Order');
SELECT dlm.add_table_to_dlm('C_OrderLine');
SELECT dlm.add_table_to_dlm('M_ReceiptSchedule_Alloc');
SELECT dlm.add_table_to_dlm('M_ReceiptSchedule');

-- flush OS caches and restart postgres; see http://stackoverflow.com/a/1223421/1012103
-- root@DBMS:~# service postgresql stop && sync && echo 3 > /proc/sys/vm/drop_caches && service postgresql start

-- do explain analyze buffer etc..again
-- pg-9.1: "Index Scan Backward using c_invoice_candidate_created on public.c_invoice_candidate_tbl      (cost=15.96..176.88 rows=1 width=1687) (actual time=0.445..268.927 rows=544 loops=1)"
-- pg-9.5: "Index Scan Backward using c_invoice_candidate_create_dlm_partial on c_invoice_candidate_tbl  (cost=16.28..172.09 rows=1 width=1682) (actual time=153.611..1564.482 rows=544 loops=1)"
-- Note: i didn't understand the pg-9.1 result..i might have made a mistake (forgot to flush? maybe actually did have the data updated?). However, the pg-9.5 result seems plausible

-- now update "some" values to generate background data
UPDATE C_Invoice_Candidate_Tbl SET DLM_Level=1 WHERE processed='Y' AND updated + interval '1 weeks' < now();
UPDATE C_Order_Tbl o SET DLM_Level=1 FROM C_Invoice_Candidate_Tbl ic WHERE o.C_Order_ID=ic.C_Order_ID AND ic.DLM_Level=1 AND COALESCE(o.DLM_Level,0)!=1;
UPDATE C_OrderLine_Tbl ol SET DLM_Level=1 FROM C_Invoice_Candidate_Tbl ic WHERE ol.C_OrderLine_ID=ic.C_OrderLine_ID AND ic.DLM_Level=1 AND COALESCE(ol.DLM_Level,0)!=1;
UPDATE M_ReceiptSchedule_Tbl rs SET DLM_Level=1 FROM C_Invoice_Candidate_Tbl ic WHERE ic.C_OrderLine_ID=rs.C_OrderLine_ID AND ic.DLM_Level=1 AND COALESCE(rs.DLM_Level,0)!=1;
UPDATE M_ReceiptSchedule_Alloc_Tbl rsa SET DLM_Level=1 FROM M_ReceiptSchedule_Tbl rs WHERE rs.M_ReceiptSchedule_ID=rsa.M_ReceiptSchedule_ID AND rs.DLM_Level=1 AND COALESCE(rsa.DLM_Level,0)!=1;

-- check out the result:
SELECT 'C_Invoice_Candidate_Tbl' as Tbl, count(*), DLM_Level FROM C_Invoice_Candidate_Tbl GROUP BY DLM_Level UNION
SELECT 'C_Order_Tbl', count(*), DLM_Level FROM C_Order_Tbl GROUP BY DLM_Level UNION
SELECT 'C_OrderLine_Tbl', count(*), DLM_Level FROM C_OrderLine_Tbl GROUP BY DLM_Level UNION
SELECT 'M_ReceiptSchedule_Tbl', count(*), DLM_Level FROM M_ReceiptSchedule_Tbl GROUP BY DLM_Level UNION
SELECT 'M_ReceiptSchedule_Alloc_Tbl', count(*), DLM_Level FROM M_ReceiptSchedule_Alloc_Tbl GROUP BY DLM_Level
ORDER BY Tbl, DLM_Level NULLS first;
/* Result:
"C_Invoice_Candidate_Tbl";254892;
"C_Invoice_Candidate_Tbl";1094035;1
"C_OrderLine_Tbl";167594;
"C_OrderLine_Tbl";786560;1
"C_Order_Tbl";7033;
"C_Order_Tbl";117259;1
"M_ReceiptSchedule_Alloc_Tbl";1895970;
"M_ReceiptSchedule_Alloc_Tbl";5269628;1
"M_ReceiptSchedule_Tbl";73179;
"M_ReceiptSchedule_Tbl";141663;1
*/


-- make sure the statistics are up to date
ANALYZE VERBOSE C_Invoice_Candidate_Tbl;
ANALYZE VERBOSE C_Order_Tbl;
ANALYZE VERBOSE C_OrderLine_Tbl;
ANALYZE VERBOSE M_ReceiptSchedule_Alloc_Tbl;
ANALYZE VERBOSE M_ReceiptSchedule_Tbl;

-- flush OS caches and restart postgres; see http://stackoverflow.com/a/1223421/1012103
-- root@DBMS:~# service postgresql stop && sync && echo 3 > /proc/sys/vm/drop_caches && service postgresql start

-- do explain analyze buffer etc..again
-- "Index Scan Backward using c_invoice_candidate_create_dlm_partial on c_invoice_candidate_tbl  (cost=15.96..  176.51 rows= 1 width=2106) (actual time=146.663..1735.551 rows=534 loops=1)" <- pg-9.1 with partial indices
-- "Index Scan Backward using c_invoice_candidate_create_dlm_partial on c_invoice_candidate_tbl  (cost=16.28..  168.21 rows= 1 width=1678) (actual time= 99.858..1607.801 rows=534 loops=1)" <- pg-9.5 with partial indices
-- "Index Scan Backward using c_invoice_candidate_create             on c_invoice_candidate_tbl  (cost=16.28..10473.15 rows=21 width=2120) (actual time= 78.620..1475.508 rows=534 loops=1)" <- pg-9.5 without partial indices
-- "Index Scan Backward using c_invoice_candidate_create             on c_invoice_candidate_tbl  (cost=16.28..10473.15 rows=21 width=2120) (actual time=106.524..1715.651 rows=534 loops=1)" <- pg-9.5 without partial indices repeat
